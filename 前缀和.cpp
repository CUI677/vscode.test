// 二维前缀和模板

// 1. 构建前缀和数组
// dp[i][j] 表示从原矩阵 (0,0) 到 (i-1,j-1) 的矩形和
// 大小为 (m+1) x (n+1)，从索引1开始，第0行和第0列都是0（哨兵，避免边界判断）
vector<vector<int>> dp(m + 1, vector<int>(n + 1));

for(int i = 1; i <= m; i++) {
    for(int j = 1; j <= n; j++) {
        // i-1, j-1: 数组索引偏移，dp从1开始，mat从0开始
        // dp[i-1][j]: 上方矩形的和
        // dp[i][j-1]: 左方矩形的和
        // dp[i-1][j-1]: 左上角重复计算的部分，需要减去
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mat[i - 1][j - 1];
    }
}

// 2. 查询子矩阵和：从原矩阵 (x1, y1) 到 (x2, y2) 的矩形和
// x1, y1, x2, y2 是原矩阵的坐标（从0开始）
int query(int x1, int y1, int x2, int y2) {
    // dp[x2+1][y2+1]: 原矩阵(0,0)到(x2,y2)的和，+1是坐标转换
    // dp[x1][y2+1]: 原矩阵(0,0)到(x1-1,y2)的和，即查询区域上方的部分
    //               x1本身就是x1-1+1，所以不需要再+1
    // dp[x2+1][y1]: 原矩阵(0,0)到(x2,y1-1)的和，即查询区域左方的部分
    //               y1本身就是y1-1+1，所以不需要再+1
    // dp[x1][y1]: 原矩阵(0,0)到(x1-1,y1-1)的和，左上角被减了两次，要加回来
    //             x1和y1都已经是偏移后的值
    return dp[x2 + 1][y2 + 1] - dp[x1][y2 + 1] - dp[x2 + 1][y1] + dp[x1][y1];
}
//原数组00对应前缀和数组11；